<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Python Basics</title>
<meta name="description" content="Python Basics">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
<link rel="stylesheet" href="assets/reveal.js/css/reveal.css">
<link rel="stylesheet" href="assets/reveal.js/css/theme/black.css" id="theme">

<!-- Code syntax highlighting -->
<link rel="stylesheet" href="assets/reveal.js/lib/css/zenburn.css">

<!-- Custom overrides -->
<link rel="stylesheet" href="assets/css/overrides.css">

<!--[if lt IE 9]>
<script src="assets/reveal.js/lib/js/html5shiv.js"></script>
<![endif]-->

<style>
	.dim {color: #a9a9a9 !important;}
	.bright {color:#fff !important;}
	.centered {text-align: center !important;}
	table.centered td {text-align: center !important;}
	table.tabular td {text-align: center !important; border-right:1px solid #ccc;}
	table.tabular td:last-child {text-align: center !important; border-right:0;}
</style>

</head>
<body>
<div class="reveal">
	<div class="slides">
		<!-- 
		Introduction 
		//-->
		<section>
			<h1>Python</h1>
			<h4 class="dim">Basics for Engineers</h4>
		</section>
        <section>
	        <section>
	            <h2>Coverage</h2>
				<br />
				<ul class="dim">
					<li>Python types (strings, lists, dicts, etc)</li>
					<li>Conditional statements</li>
					<li>Loops</li>
					<li>List comprehension</li>
					<li>Exception Handling</li>
					<li>Functions and Classes</li>
					<li>Files I/O and Modules</li>
					<li>Overview of standard libraries, packaging and tools</li>
				</ul>
	        </section>

	        <section>
	            <h2>Versions</h2>
				<br>
				<ul class="dim">
					<li>
						<h3 style="margin-bottom:5px;">Python 2.<span style="text-transform:lowercase">x</span></h3>
						- Some libraries only works in Python 2.*
						<br />
						- Python 2.7 (current of 2.x branch) was started back in 2010 and will end it's support in 2020
					</li>
					<li style="list-style:none;"><br/></li>
					<li>
						<h3 style="margin-bottom:5px;">Python 3.<span style="text-transform:lowercase">x</span></h3>
						- Getting the majority of Python's current development
						<br>
						- Future of Python
					</li>
				</ul>
			</section>

	        <section>
	            <h2>History</h2>
				<br>
				<ul class="dim">
					<li>General-purpose programming language</li>
					<li>Multi-paradigm (OOP, FP, procedural, ...)</li>
					<li>Dynamic and strongly-typed</li>
					<li>Created in the late 1980s; released in 1991</li>
					<li>Created and designd by Guido van Rossum</li>
				</ul>
			</section>

			<section>
				<h2>Installation</h2>
				<br>
				<span class="dim">
					<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>
				</span>
			</section>

			<section>
				<h2>IDE / Shell</h2>
				<br>
				<ul class="dim">
					<li>Command Prompt / PowerShell / Terminal</li>
					<li>Text Editors (Sublime Text, VS Code, Atom, ...)</li>
					<li>Jupyter, IDLE, Thonny</li>
					<li>PyCharm</li>
				</ul>
			</section>
		</section>

		<!-- 
		Style Guide 
		//-->
		<section>
		    <h1>Style Guide</h1>
		</section>
		<section>
	        <section>
	            <h3>Coding Styles and Conventions</h3>
				<br>
				<span class="dim" style="font-size:80%">
					For preferred code styling and conventions, refer to the links below:
					<a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a>
					<br>
					<a href="http://docs.python-guide.org/en/latest/writing/style/">http://docs.python-guide.org/en/latest/writing/style/</a>
				</span>
				<pre>
					<code>
# This is a comment.

"""
This is a multi-line comment (also called docstring). 
Single quotes can also be used.
"""

# Spaces are the preferred indentation over tabs.
# Don't mixed tabs and spaces for indentation.
# Use 4 spaces per indentation level (optional).
					</code>
				</pre>
			</section>

	        <section>
				<h3>Keywords</h3>
				<p class="dim" style="font-size:80%">
					Keywords are the reserved words in Python.
					<br>						
					We cannot use a keyword as variable name, function name or any other identifier. 
					They are used to define the syntax and structure of the Python language.					
				</p>
				<table class="centered tabular" style="font-size:80%">
				<tr>
					<td>False</td>
					<td>class</td>
					<td>finally</td>
					<td>is</td>
					<td>return</td>
				</tr>
				<tr>
					<td>None</td>
					<td>continue</td>
					<td>for</td>
					<td>lambda</td>
					<td>try</td>
				</tr>
				<tr>
					<td>True</td>
					<td>def</td>
					<td>from</td>
					<td>nonlocal</td>
					<td>while</td>
				</tr>
				<tr>
					<td>and</td>
					<td>del</td>
					<td>global</td>
					<td>not</td>
					<td>with</td>
				</tr>
				<tr>
					<td>as</td>
					<td>elif</td>
					<td>if</td>
					<td>or</td>
					<td>yield</td>
				</tr>
				<tr>
					<td>assert</td>
					<td>else</td>
					<td>import</td>
					<td>pass</td>
					<td></td>
				</tr>
				<tr>
					<td>break</td>
					<td>except</td>
					<td>in</td>
					<td>raise</td>
					<td></td>
				</tr>
				</table>
			</section>

	        <section>
				<h2>Data Types</h2>
				<br>
				<ul class="dim">
					<li>Numbers</li>
					<li>String</li>
					<li>List</li>
					<li>Tuple</li>
					<li>Set</li>
					<li>Dictionary</li>
				</ul>
			</section>

	        <section>
				<h3>Things to care about</h3>
				<p class="dim" style="font-size:80%">
					Python is a case-sensitive language. This means, <span class="bright">Variable</span> and <span class="bright">variable</span> are not the same. 
					Always name identifiers that make sense.
					<br>
					<br>
					While, <span class="bright">c = 10</span> is valid. Writing <span class="bright">count = 10</span> would make more sense and it would be easier to 
					figure out what it does even when you look at your code after a long gap.
					<br>
					<br>
					Multiple words can be separated using an underscore, ie. <span class="bright">this_is_a_long_variable</span>
					<br>
					<br>
					We can also use camel-case style of writing, i.e., capitalize every first letter of the word 
					except the initial word without any spaces. ie, <span class="bright">camelCaseExample</span>
				</p>
			</section>
		</section>

		<!-- 
		Standard Data Types 
		//-->
		<section>
		    <h1>Standard <br>Data Types</h1>
		</section>
		<section>
	        <section>
	            <h2>Numbers</h2>
				<br>
				<span class="dim">
					Number data types store numeric values. Number objects are created when you assign a value to them.
				</span>
				<pre>
					<code>
num1 = 2017   # For long integer, 
              # the "L" suffix is only supported in Python 2.x
			  
num2 = 1.5    # floating point

num3 = 8j     # complex number
					</code>
				</pre>
			</section>
			
	        <section>
	            <h3>Number system prefix</h3>
				<br>
				<span class="dim" style="font-size:90%">
					Other number system aside from <span class="bright">decimal</span> (base 10) are <span class="bright">binary</span> (base 2), 
					<span class="bright">hexadecimal</span> (base 16) and <span class="bright">octal</span> (base 8) number systems.
					<br>
					In Python, we can represent these numbers by appropriately placing a prefix before that number. 
					Following table lists these prefix.				
				</span>
				<table>
				<tr>
					<th>Number system</th>
					<th>Prefix</th>
				</tr>
				<tr>
					<td>binary</td>
					<td class="dim">0b or 0B</td>
				</tr>
				<tr>
					<td>octal</td>
					<td class="dim">0o or 0O</td>
				</tr>
				<tr>
					<td>hexadecimal</td>
					<td class="dim">0x or 0X</td>
				</tr>
				</table>
			</section>

	        <section>
	            <h2>Strings</h2>
				<br>
				<span class="dim">
					Identified as a contiguous set of characters represented in the quotation marks. 
					Python allows for either pairs of single or double quotes.
				</span>
				<pre>
					<code>
str1 = 'hello'
str2 = "hello"
str3 = "'hello world'"
str4 = '"hello world"'
str5 = "'single quote here'"
str6 = """Hello
          to the
          world!
       """
					</code>
				</pre>
			</section>
			
	        <section>
				<h3>String Concantenation</h3>
				<br>
				<span class="dim">
					Joining of two or more strings into one is called <span class="bright">concatenation</span>.
				</span>
				<pre>
					<code>
# using +
str1 = 'hello' + 'world!'

# multiple string literals together
str2 = 'hello' ' to the ' 'world!'

# using ()
str3 = ('hello '
        'to the '
        'world')
	   
# using *
print('----' * 3)
					</code>
				</pre>
			</section>
			
	        <section>
	            <h3>Accessing Strings</h3>
				<br>
				<span class="dim" style="font-size:90%">
					We can access individual characters using indexing and a range of characters using slicing. 
					Index starts from <span class="bright">0</span>.
					<br>
					Python allows negative indexing for its sequences. With this, indexes are read in reverse.
				</span>
				<pre>
					<code>
str = "Hello to the world!"

print(str)           # Prints the whole string
print(str[0])        # Prints the first character
print(str[1:5])      # Prints characters starting from 2nd to 5th
print(str[-1])       # Prints the last character of the string
print(str[::-1])     # Prints the string in reverse
					</code>
				</pre>
			</section>

	        <section>
	            <h3>String Formatting</h3>
				<br>
				<pre>
					<code style="font-size:90%">
# escaped sequence						
print('I don\'t like programming, ever!')

# raw string to ignore escape sequence
print(r"This is \x61 \ntest")

# old-style formatting
print('Hello %s!' % 'world')

# preferred formatting
print('Hello {}!'.format('world'))

# order using positional argument
print('{1} {0} ready, go!'.format(2, 1))

# order using keyword argument
print('My name is {last}, {first} {last}'.format(first='James', last='Bond'))
					</code>
				</pre>
			</section>
			
	        <section>
	            <h2>Lists</h2>
				<br>
				<span class="dim">
						A list a sequence of objects separated by commas and enclosed in square brackets ([]) similar to arrays in C.
						<br>
						Items in a list can be of any type.
				</span>
				<pre>
					<code>
arr = [2017, 1.5, 8j, "This string has a \tab, isn't it?"]

print(arr)            # Prints all the list items
print(arr[-1])        # Prints the last element of the list
print(arr[:-2])       # Prints all items except the last two elements
print(arr * 2)        # Prints the list twice
print(arr + [9,10])   # Prints a concantenated list
					</code>
				</pre>
			</section>
			
	        <section>
	            <h2>Tuples</h2>
				<br>
				<span class="dim">
					A tuple is another sequenced or ordered data type that is similar to a list but is enclosed in parenthesis,
					however, tuples items cannot be modified or updated anymore.
				</span>
				<pre>
					<code>
arr = (2017, 1.5, 8j, "This string has a \tab, isn't it?")

# you can do this to (minus the parenthesis)
arr = 2017, 1.5, 8j, "This string has a \tab, isn't it?"

print(arr[:])         # Prints all the tuple items
print(arr[0:0])       # Prints an empty tuple
print(arr[::-1])      # Prints the items in reversed order
print(arr * 2)        # Prints the tuple twice
print(arr + (9,10))   # Prints a concantenated tuple
					</code>
				</pre>
			</section>
			
	        <section>
	            <h2>Dictionary</h2>
				<br>
				<span class="dim">
					An unordered associative array (hashes) where any key of the dictionary is mapped to a value, 
					often referred to as key-value pair.
					Dictionaries are enclosed in curly braces and like lists and tuples, values of a dictionary can be any data type.
				</span>
				<pre>
					<code>
dict = {
    'name': 'Jon Snow',
    8j: 2017
}

print(dict)             # Prints the whole dictionary
print(dict['name'])     # Prints the value for the key named 'name'
					</code>
				</pre>
			</section>
			
	        <section>
	            <h2>Type Conversion</h2>
				<br>
				<p class="dim" style="font-size:90%">
					Python defines type conversion functions to directly convert one data type to another, 
					also known as <span class="bright">coercion</span>.
				</p>
				<table style="font-size:90%">
				<tr>
					<th>Function</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>int(x)</td>
					<td class="dim">Converts x to an integer.</td>
				</tr>
				<tr>
					<td>float(x)</td>
					<td class="dim">Converts x to a floating point number.</td>
				</tr>
				<tr>
					<td>char(x)</td>
					<td class="dim">Converts an integer to a character.</td>
				</tr>
				<tr>
					<td>list(x)</td>
					<td class="dim">Converts x to a list.</td>
				</tr>
				<tr>
					<td>tuple(x)</td>
					<td class="dim">Converts x to a tuple.</td>
				</tr>
				<tr>
					<td>bool(x)</td>
					<td class="dim">Converts x to a boolean type.</td>
				</tr>
				</table>
			</section>

	        <section>
				<h2>Where's my Boolean?</h2>
				<br>
				<p class="dim">
					Boolean type was introduced with the primary goal of making goal clearer and 
					two new constants where introduced, <span class="bright">True</span> and <span class="bright">False</span>.
					<br>
					<br>
					The Boolean type is a subclass of the <span class="bright">int</span> class so that arithmetic using a Boolean still works.
				</p>
			</section>

	        <section>
				<h2>Constants</h2>
				<br>
				<p class="dim">
					A small number of constants live in the built-in namespace.
				</p>
				<ul>
					<li>True</li>
					<li>False</li>
					<li>None</li>
					<li class="dim">NotImplemented</li>
					<li class="dim">Ellipsis</li>
					<li class="dim">__debug__</li>
				</ul>
			</section>
		</section>

		<!-- 
		Python Operators 
		//-->
		<section>
			<h1>Python Operators</h1>
		</section>
		<section>
	        <section>
	            <h2>Python Operators</h2>
				<br>
				<p class="dim" style="font-size:90%">
					Operators are special symbols in Python that carry out arithmetic or logical computation. 
					Operators are classified below:
				</p>
				<br>
				<ul>
					<li>Arithmetic operators</li>
					<li>Comparison (Relational) operators</li>
					<li>Logical (Boolean) operators</li>
					<li>Bitwise operators</li>
					<li>Assignment operators</li>
					<li>Special operators</li>
				</ul>
			</section>
			
	        <section>
	            <h3>Arithmetic operators</h3>
				<br>
				<p class="dim" style="font-size:80%;margin-top:-20px;">
					Arithmetic operators are used to perform mathematical operations like addition, subtraction, multiplication etc.
				</p>
				<table style="font-size:80%">
				<tr>
					<th>Operator</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td align="center">+</td>
					<td class="dim">Add two operands or unary plus</td>
				</tr>
				<tr>
					<td align="center">-</td>
					<td class="dim">Subtract right operand from the left or unary minus</td>
				</tr>
				<tr>
					<td align="center">*</td>
					<td class="dim">Multiply two operands</td>
				</tr>
				<tr>
					<td align="center">/</td>
					<td class="dim">Divide left operand by the right one (always results into float)</td>
				</tr>
				<tr>
					<td align="center">%</td>
					<td class="dim" style="font-size:90%">Modulus - remainder of the division of left operand by the right</td>
				</tr>
				<tr>
					<td align="center">//</td>
					<td class="dim" style="font-size:90%">Floor division - division that results into whole number adjusted to the left in the number line</td>
				</tr>
				<tr>
					<td align="center">**</td>
					<td class="dim">Exponent - left operand raised to the power of right</td>
				</tr>
				</table>
			</section>
			
	        <section>
	            <h3>Comparison operators</h3>
				<br>
				<p class="dim" style="font-size:80%;margin-top:-20px;">
					Comparison operators are used to compare values. It either returns <span class="bright">True</span> or 
					<span class="bright">False</span> according to the condition.
				</p>
				<table style="font-size:80%">
				<tr>
					<th>Operator</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td align="center">&gt;</td>
					<td class="dim">True if left operand is greater than the right</td>
				</tr>
				<tr>
					<td align="center">&lt;</td>
					<td class="dim">True if left operand is less than the right</td>
				</tr>
				<tr>
					<td align="center">==</td>
					<td class="dim">True if both operands are equal</td>
				</tr>
				<tr>
					<td align="center">!=</td>
					<td class="dim">True if operands are not equal</td>
				</tr>
				<tr>
					<td align="center">&gt;=</td>
					<td class="dim">True if left operand is greater than or equal to the right</td>
				</tr>
				<tr>
					<td align="center">&lt;=</td>
					<td class="dim">True if left operand is less than or equal to the right</td>
				</tr>
				</table>
	        </section>

	        <section>
	            <h3>Logical operators</h3>
				<br>
				<p class="dim">
					Logical operators are the <span class="bright">and</span>, <span class="bright">or</span>, <span class="bright">not</span> operators.
				</p>
				<table>
				<tr>
					<th>Operator</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td align="center">and</td>
					<td class="dim">True if both the operands are true</td>
				</tr>
				<tr>
					<td align="center">or</td>
					<td class="dim">True if either of the operands is true</td>
				</tr>
				<tr>
					<td align="center">not</td>
					<td class="dim">True if operand is false (complements the operand)</td>
				</tr>
				</table>
	        </section>

	        <section>
	            <h3>Bitwise operators</h3>
				<br>
				<p class="dim" style="font-size:90%">
					Bitwise operators act on operands as if they were string of binary digits. It operates bit by bit, hence the name.					
				</p>
				<table style="font-size:90%">
				<tr>
					<th>Operator</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td align="center">&amp;</td>
					<td class="dim">Bitwise AND</td>
				</tr>
				<tr>
					<td align="center">|</td>
					<td class="dim">Bitwise OR</td>
				</tr>
				<tr>
					<td align="center">~</td>
					<td class="dim">Bitwise NOT</td>
				</tr>
				<tr>
					<td align="center">^</td>
					<td class="dim">Bitwise XOR</td>
				</tr>
				<tr>
					<td align="center">&gt;&gt;</td>
					<td class="dim">Bitwise right shift</td>
				</tr>
				<tr>
					<td align="center">&lt;&lt;</td>
					<td class="dim">Bitwise left shift</td>
				</tr>
				</table>
	        </section>

	        <section>
	            <h3>Assignment operators</h3>
				<br>
				<p class="dim" style="font-size:90%">
					The basic assignment operator is the equal sign ( <span class="bright">=</span> ) 
					which assigns the value of its right operand to its left operand. 
					That is, <span class="bright">x = y</span> assigns the value of <span class="bright">y</span> to <span class="bright">x</span>.
					<br>
					<br>
					The other assignment operators are usually shorthand for standard operations, most commonly the <span class="bright">arithmetic</span> and <span class="bright">bitwise</span> operators.
				</p>
	        </section>

	        <section>
				<h2>Special operators</h2>
			</section>

	        <section>
	            <h3>Identity operators</h3>
				<br>
				<p class="dim" style="font-size:90%">
					<span class="bright">is</span> and <span class="bright">is not</span> are the identity operators in Python. 
					They are used to check if two values (or variables) are located on the same part of the memory. 
					<br>Two variables that are equal does not imply that they are identical.					
				</p>
				<table style="font-size:90%">
				<tr>
					<th>Operator</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td align="center">is</td>
					<td class="dim">True if the operands are identical (refer to the same object)</td>
				</tr>
				<tr>
					<td align="center">is not</td>
					<td class="dim">True if the operands are not identical (do not refer to the same object)</td>
				</tr>
				</table>
	        </section>

	        <section>
	            <h3>Membership operators</h3>
				<br>
				<p class="dim" style="font-size:90%">
					<span class="bright">in</span> and <span class="bright">not in</span> are the membership operators in Python. 
					They are used to test whether a value or variable is found in a sequence (string, list, tuple, set and dictionary).					
				</p>
				<table style="font-size:90%">
				<tr>
					<th>Operator</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td align="center">in</td>
					<td class="dim">True if value/variable is found in the sequence</td>
				</tr>
				<tr>
					<td align="center">not in</td>
					<td class="dim">True if value/variable is not found in the sequence</td>
				</tr>
				</table>
	        </section>
		</section>

		<!-- 
		Flow Control
		//-->
		<section>
			<h1>Flow Control</h1>
		</section>
		<section>
	        <section>
	            <h2>If-Else</h2>
				<br>
				<pre>
					<code>
# if statement
if True:
   print('Yes, it\'s true')


# if-else statement
if True:
   print('Yes, it\'s true')
else:
   print('Nope')

   
# if-else-if statement
num = 2
if num > 2:
   print('Yes, it\'s true')
elif num < 1:
   print('Nope')
else:
   print('Maybe?')
					</code>
				</pre>
			</section>
	        <section>
	            <h3>Nested If-Else</h3>
				<br>
				<pre>
					<code>
# In this program, we input a number
# check if the number is positive or
# negative or zero and display
# an appropriate message

num = float(input('Enter a number: '))

if num >= 0:
   if num == 0:
      print('Zero')
   else:
      print('It\'s positive!')
else:
   print('Nope')
					</code>
				</pre>
			</section>

	        <section>
	            <h2>For-Loop</h2>
				<br>
				<p class="dim">
					The for loop in Python is used to iterate over a sequence (list, tuple, string) or other iterable objects.
					<br>
					Iterating over a sequence is called <span class="bright">traversal</span>.
				</p>
				<pre>
					<code>
# syntax of for-loop
for val in sequence:
    # context here
					</code>
				</pre>
			</section>
	        <section>
	            <h3>For-Loop Example</h3>
				<br>
				<pre>
					<code>
# prints 1, 2, 3 at a time
arr = (1, 2, 3)
for i in arr:
    print(i)
	

# calculates the sum of the list
sum = 0
for i in arr:
    sum += i
	
print(sum)    # prints 6
					</code>
				</pre>
			</section>
	        <section>
	            <h3>For-Loop: Using range()</h3>
				<br>
				<p class="dim" style="font-size:80%">
					<span class="bright">range()</span> is a built-in function that generates a sequence of numbers.
					<br>
					We can also define the start, stop and the increment size as <span class="bright">range(start, stop, increment)</span>.
					By default sequence starts at <span class="bright">0</span> and the size of the increment defaults to <span class="bright">1</span> if not specified.
				</p>
				<pre>
					<code>
print(tuple(range(10)))   # prints (0,1,2,3,4,5,6,7,8,9)

# display 0 -> 9 at a time
for i in range(10, -1):
    print(i)

# prints 1,3,5,7,9
for i in range(1,10,2):
    print(i)
					</code>
				</pre>
			</section>

	        <section>
	            <h2>While-Loop</h2>
				<br>
				<p class="dim">
					The while loop in Python is used to iterate over a block of code as long as 
					the test expression (condition) is true.
					<br>	
					We generally use this loop when we don't know beforehand, the number of times to iterate.
				</p>
				<pre>
					<code>
# syntax of while-loop
while expression:
    # context here
					</code>
				</pre>
			</section>
	        <section>
	            <h3>While-Loop Example</h3>
				<br>
				<pre>
					<code>
# calculates the sum
iterations = 3
sum = 0
i = 0

while i <= iterations:
      sum += i
      i += i
	  
print(sum)    # prints 6
					</code>
				</pre>
			</section>

	        <section>
	            <h2>Break/Continue</h2>
				<br>
				<p class="dim" style="font-size:90%">
					The <span class="bright">break</span> statement terminates the loop containing it. 
					<br>
					Control of the program flows to the statement immediately after the body of the loop.
					<br>
					If break statement is inside a nested loop (loop inside another loop), 
					break will terminate the innermost loop.
					<br>
					<br>
					The <span class="bright">continue</span> statement is used to skip the rest of the code inside a loop for the 
					current iteration only. Loop does not terminate but continues on with the next iteration.
				</p>
			</section>

	        <section>
	            <h2>Pass Statement</h2>
				<br>
				<p class="dim" style="font-size:90%">
					In Python programming, pass is a null statement. 
					The difference between a comment and pass statement in Python is that, 
					while the interpreter ignores a comment entirely, pass is not ignored.
					<br>
					<br>
					However, nothing happens when pass is executed.
				</p>
				<pre>
					<code>
if None:
   pass  # don't do anything

def do_it_now():
    pass
					</code>
				</pre>
			</section>
		</section>

		<!-- 
		Functions
		//-->
		<section>
			<h1>Functions</h1>
		</section>
		<section>
	        <section>
				<h2>What is a function?</h2>
				<br>
				<p class="dim" style="font-size:90%">
					A function is a group of related statements that<br>perform a specific task.
					<br>
					Functions help break our program into smaller and modular chunks. 
					As our program grows larger and larger, functions make it more organized and manageable.
					<br>
					Furthermore, it avoids repetition and makes code reusable.
				</p>
				<pre>
					<code>
# function declaration
def function_name(parameters):
    statement(s)
					</code>
				</pre>
			</section>
	        <section>
				<h3>Function breakdown</h3>
				<pre>
					<code>
def function_name(parameters):
    statement(s)
					</code>
				</pre>
				<ul class="dim" style="font-size:80%">
					<li>Keyword <span class="bright">def</span> marks the start of function header.</li>
					<li>A <span class="bright">function name</span> to uniquely identify it.</li>
					<li><span class="bright">Parameters</span> (arguments) through which we pass values to a function (optional).</li>
					<li>A colon ( <span class="bright">:</span> ) to mark the end of function header.</li>
					<li>One or more valid python statements that make up the function body. Statements must have same indentation level (usually 4 spaces).</li>
					<li>An optional return statement to return a value from the function.</li>
				</ul>
			</section>
	        <section>
				<h3>Function call</h3>
				<pre>
					<code>
# Displays a message
def say_hello():
    print('Hello world!')
	
>>> say_hello()              # prints 'Hello world'
	

# This function calculates the sum of two numbers
def add_this_numbers(num1, num2):
    num3 = num1 + num2
    return num3

>>> add_this_numbers(1, 2)   # prints 3
					</code>
				</pre>

				<p class="dim" style="font-size:80%">
					The above function definitions are called <span class="bright">User-defined</span> functions.
				</p>
			</section>
	        <section>
				<h3>Built-in Functions</h3>
				<br>
				<p class="dim" style="font-size:80%">
					The Python interpreter has a number of functions that are always available for use. 
					<br>
					<br>
					These functions are called built-in functions. 
					For example, <span class="bright">print()</span> function prints the given object to the screen.
					<br>
					<br>
					See <a href="https://docs.python.org/3/library/functions.html">https://docs.python.org/3/library/functions.html</a> for complete of built-in Python 3.x functions.
				</p>
			</section>

	        <section>
				<h2>Function Arguments</h2>
				<br>
				<p class="dim" style="font-size:80%">
					The arguments in the function definition bind the arguments passed at function 
					invocation (i.e. when the function is called), which are called actual parameters, 
					to the names given when the function is defined, which are called formal parameters.
					<br>
					<br>
					Arguments can be of any type depending how the function is being defined.
					Functions can have a fix number of arguments or could be variable, or can be optional.
				</p>
			</section>

	        <section>
				<h2>Variable Function Arguments</h2>
				<br>
				<p class="dim">
					In Python there are other ways to define a function which can take variable number of arguments.
					<br>
					<br>
					There are 3 different forms of this type.
				</p>
				<ul class="dim">
					<li>Default Arguments</li>
					<li>Keyword Arguments</li>
					<li>Arbitrary Arguments</li>
				</ul>
			</section>
	        <section>
				<h3>Default Arguments</h3>
				<br>
				<p class="dim">
					Function arguments can have default values in Python.
					<br>	
					To provide a default value to an argument by using the assignment operator ( <span class="bright">=</span> ).
				</p>
				<pre>
					<code>
def say_hello(msg, prefix='Hello'):
    print(prefix, msg)
	

>>> say_hello('world')                   # prints "Hello world"
>>> say_hello('to the world', 'hi,')     # prints "hi, to the world"
					</code>
				</pre>
			</section>
	        <section>
				<h3>Keyword Arguments</h3>
				<br>
				<p class="dim">
					When we call a function with parameters, 
					these values get assigned to the arguments according to their position.
				</p>
				<pre>
					<code>
def say_hello(msg, prefix='Hello'):
    print(prefix, msg)
	

# 2 keyword arguments, unordered
>>> say_hello(prefix='Yes', msg='yo!')

# 1 positional, 1 keyword argument
>>> say_hello('to the world', prefix='hi!')
					</code>
				</pre>
			</section>
	        <section>
				<h3>Arbitrary Arguments</h3>
				<br>
				<p class="dim" style="font-size:80%">
					The special syntax, <span class="bright">*args</span> and <span class="bright">**kwargs</span> in function definitions is used to pass a 
					variable number of arguments to a function. 
					<br>
					The single asterisk form ( <span class="bright">*args</span> ) is used to pass a <span class="bright">non-keyworded</span>, 
					variable-length argument list, and the <span class="bright">double asterisk</span> form is used to pass a <span class="bright">keyworded</span>, 
					variable-length argument list.
					<br>
					The asterisk denotation ( <span class="bright">*</span> ) used is also referred to as 
					the <span class="bright">splat operator</span>.
				</p>
				<pre>
					<code>
def say_hello(*msgs):
    for msg in msgs:
        print(msg)
					</code>
				</pre>
			</section>

			<section>
				<h2>Anonymous Functions</h2>
				<br>
				<p class="dim" style="font-size:80%">
					In Python, anonymous function is a function that is<br>defined <span class="bright">without a name</span>.
					<br>
					While normal functions are defined using the <span class="bright">def</span> keyword, 
					in Python anonymous functions are defined using the <span class="bright">lambda</span> keyword.
					<br>
					Hence, anonymous functions are also called <span class="bright">lambda functions</span>.
				</p>
				<pre>
					<code>
# syntax
lambda arguments: expression
					</code>
				</pre>
				<p class="dim" style="font-size:80%;margin-top:-30px;">
					Lambda functions can have any number of arguments but <span class="bright">only one expression</span>. 
					The expression is evaluated and returned. 
				</p>
			</section>
	        <section>
				<h3>Example of Lambda Function</h3>
				<pre>
					<code>
# calculates the nth power of a number
npower = lambda x,y: x ** y
					</code>
				</pre>
				<p class="dim" style="font-size:80%;">
					The above lambda function can be expressed in a similar way using the usual function definition as below:
				</p>
				<pre>
					<code>
# calculates the nth power of a number
def npower(x,y):
    return x ** y
					</code>
				</pre>
			</section>
		</section>
		
		<!-- 
		Files I/O
		//-->
		<section>
			<h1>Files I/O</h1>
		</section>
		<section>
	        <section>
				<h2>Screen Ouput</h2>
				<br>
				<p class="dim" style="font-size:90%">
					Sends output to the screen, which is the standard ouput pipe.
				</p>
				<pre>
					<code>
"""
The following examples displays similarly
"""
print("Hello" + " to the " + "world")
print("hello", "to", "the", "world")

str = ("hello", "to", "the", "world")
for s in str:
    print(s, end=' ')
					</code>
				</pre>
				<p class="dim" style="font-size:90%">
					On the other hand, print output can also be logged to a file.
				</p>
			</section>
	        <section>
				<h2>Keyboard Input</h2>
				<br>
				<p class="dim" style="font-size:90%">
					Python provides two built-in functions to read a line of text from standard input, 
					which by default comes from the keyboard. 
				</p>
				<pre>
					<code>
name = input("Enter your name: ")
print("Hi ", name)
					</code>
				</pre>
				<p class="dim" style="font-size:90%">
					In Python 2.x, input string will be automatically evaluated. To evalute data input in Python 3.x,
					you have to explicitly call the <span class="bright">eval()</span> method.
				</p>
			</section>
	        <section>
				<h3>Command-line Argument</h3>
				<br>
				<p class="dim" style="font-size:80%;margin-top:-20px;">
					Of course, we might want to accept user input as arguments to our program 
					rather than after it starts.
					<br>
					<span class="bright">argv</span> is a list containing all the command line arguments.
				</p>
				<pre>
					<code style="font-size:90%">
# test.py
import sys
print(sys.argv[1:])  # display the arguments
					</code>
				</pre>
				<pre>
					<code style="font-size:90%;margin-top:-50px;">
# running the script from the command line
$ python test.py param1 param2

# outputs
['param1', 'param2']
					</code>
				</pre>
			</section>
	        <section>
				<h2>File Operations</h2>
				<br>
				<p class="dim" style="font-size:80%;margin-top:-20px;">
					Python provides basic functions and methods necessary to manipulate files by default. 
					You can do most of the file manipulation using a file object.
				</p>
				<pre>
					<code style="font-size:90%">
# syntax
file object = open(file_name [, mode][, ...])
					</code>
				</pre>
				<pre>
					<code style="font-size:90%;margin-top:-50px;">
# opens a file for reading
fp = open('file.txt', 'r')

# opens a file for writing
fp = open('file.txt', 'w')
					</code>
				</pre>
			</section>
	        <section>
				<h3>Open Function</h3>
				<br>
				<p class="dim" style="font-size:90%;margin-top:-20px;">
					Details for the <span class="bright">open()</span> function commonly-used parameters.
				</p>
				<pre>
					<code style="font-size:90%">
# syntax
file object = open(file_name [, mode][, ...])
					</code>
				</pre>
				<table class="dim" style="font-size:80%;margin-top:-20px;">
				<tr>
					<td class="bright">file_name</td>
					<td>
						Path to the file you want to access.
					</td>
				</tr>
				<tr>
					<td class="bright">mode</td>
					<td>
						Determines the mode in which the file has to be opened, i.e., 
						read, write, append, etc. This is an optional parameter and the default file access mode is read (r).
					</td>
				</tr>
				</table>
				<br>
				<p class="dim" style="font-size:80%;margin-top:-10px;">
					To see complete parameter details, enter the command <span class="bright">help(open)</span> 
					in your Python shell.
				</p>
			</section>
	        <section>
				<h3>File Read</h3>
				<pre>
					<code style="font-size:80%">
fp = open("file.txt")    # Open file for reading
while True:
    str = fp.read(10)    # read 10 bytes
    if str == '':
       break
    print(str)
fp.close()               # close opened file (important)
					</code>
				</pre>
				<p class="dim" style="font-size:85%;margin-top:-40px;">
					Preferred way of reading file in Python. 
					The <span class="bright">with</span> statement handles opening and closing the file, 
					including if an exception is raised in the inner block. 
				</p>
				<pre>
					<code style="font-size:90%;margin-top:-20px;">
with open('file.txt') as fp:
     for str in fp:
         print(str)
					</code>
				</pre>
			</section>
	        <section>
				<h3>File Write</h3>
				<p class="dim" style="font-size:90%">
					The <span class="bright">write()</span> method writes any string to an open file.
					<br>
					It is important to note that Python strings can have binary data and not just text.
					Also, the <span class="bright">write()</span> method does not add a newline character 
					( <span class="bright">'\n'</span> ) to the end of the string.
				</p>
				<pre>
					<code style="font-size:90%">
# Open file for writing						
fp = open("file.txt", "wb")   
fp.write("Hello to the world!\n")

# close opened file (important)
fp.close()
					</code>
				</pre>
				<p class="dim" style="font-size:85%">
					To see other methods for file operations, use <span class="bright">help(&lt;file object&gt;)</span>.
				</p>
			</section>
		</section>
		
		<!-- 
		Exception Handling
		//-->
		<section>
			<h1>Exception<br>Handling</h1>
		</section>
		<section>
	        <section>
				<h2>Exception Handling</h2>
				<br>
				<p class="dim" style="font-size:90%">
					Python provides two very important features to handle any unexpected error in your Python programs and to add debugging capabilities in them. They are:
				</p>
				<br>
				<ul>
					<li>Exception Handling</li>
					<li class="dim">Assertion</li>
				</ul>
			</section>
	        <section>
				<h3>Exception Pseudo-code Breakdown</h3>
				<pre>
					<code style="max-height:800px">
try:
    pass
except SomeException:
    # Handle a instance of SomeException or a subclass of it.
    pass
except Exception:
    # Handle any other exception that inherits from Exception
    # doesn't include GeneratorExit, KeyboardInterrupt, SystemExit
    pass
else:
    # there was no exception whatsoever
    # if no exception, the "something()" gets evaluated, 
    # return statement will be executed unless a return statement
    # is specified in the 'finally' block
    pass
finally:
    # this block will execute no matter what, even if no exception,
    # after "something" is eval'd but before that value is returned
    # but even if there is an exception.
					</code>
				</pre>
			</section>
	        <section>
				<h3>Exception Handling Example</h3>
				<pre>
					<code style="max-height:800px">
fp = None
try:
    # Open file for read + writing
    fp = open('test.txt', 'r+')
    fp.write('Hello to the world!')
	
except IOError as e:
    # Display error
    print('Error found:', e)
	
finally:
    # Close file handle
    if fp:
        fp.close()						
					</code>
				</pre>
			</section>
	        <section>
				<h2>Raising Exceptions</h2>
				<br>
				<p class="dim" style="font-size:85%">
					The raise statement does two things: <span class="bright">1)</span> it creates an exception object, 
					and; <span class="bright">2)</span> immediately leaves the expected program execution sequence to search the enclosing try statements for a matching except clause. 
					<br>
					<br>
					The effect of a raise statement is to either divert execution in a matching except suite, or to stop the program because no matching except suite was found to handle the exception.
				</p>
				<pre>
					<code>
# syntax
raise Exception([msg][, ...])
					</code>
				</pre>
			</section>
	        <section>
				<h3>Raising Exceptions: Example</h3>
				<pre>
					<code>
"""
This program will stop and raise a generic exception
if zero is found
"""

dividend = float(input('Enter number to divide: '))
divisor = float(input('Enter divisor: '))

if (divisor <= 0.0):
   raise Exception('Divisor cannot be zero')

print(dividend / divisor)
					</code>
				</pre>
				<p class="dim" style="font-size:90%">
					For a complete list of Exceptions and Errors, see <a href="https://docs.python.org/3/library/exceptions.html">https://docs.python.org/3/library/exceptions.html</a>
				</p>
			</section>
		</section>
		
		<!-- 
		List Comprehension
		//-->
		<section>
			<h1>List<br>Comprehension</h1>
		</section>
		<section>
	        <section>
				<h2>What are list comprehensions?</h2>
				<br>
				<p class="dim" style="font-size:90%">
					List comprehensions are a tool for transforming one list (any iterable actually) into another list. 
					During this transformation, elements can be conditionally included in the new list and each element can be 
					transformed as needed.
					<br>
					<br>
					Every list comprehension can be rewritten as a for loop but not every for loop can be rewritten as a list comprehension.
				</p>
			</section>
	        <section>
				<h3>List comprehension example</h3>
				<pre>
					<code>
# Get all even numbers between 1 and 10
arr = []
for i in range(1,10):
    if i % 2 == 0:
       arr.append(i)
print(arr)
					</code>
				</pre>
				<p class="dim" style="font-size:90%">
					The above can be rewritten using list comprehension like below:
				</p>
				<pre>
					<code>
# Get all even numbers between 1 and 10
arr = [i for i in range(1,10) if i % 2 == 0]
print(arr)
					</code>
				</pre>
			</section>
		</section>
	
		<!-- 
		Modules
		//-->
		<section>
			<h1>Modules</h1>
		</section>
		<section>
			<section>
				<h2>Modules</h2>
				<br>
				<p class="dim" style="font-size:90%">
					A module is a file containing Python definitions and statements.
					<br>
					The <span class="bright">file name</span> is the <span class="bright">module name</span> with the suffix, 
					<span class="bright">.py</span> appended.
					<br>
					<br>
					Recommended naming convention for modules &amp; packages:
				</p>
				<ul class="dim" style="font-size:90%">
					<li>It is encouraged to use <span class="bright">short</span>, <span class="bright">all-lowercase names</span> for modules</li>
					<li>Underscores can be used in the module name if it improves readability</li>
					<li><span class="bright">DON'T use the dot (.) character</span> in naming modules. You will see later why this is the case.</li>
				</ul>
			</section>
			<section>
				<h3>Importing Modules</h3>
				<p class="dim" style="font-size:90%">
					To use a module, we use the <span class="bright">import</span> command.
				</p>
				<pre>
					<code style="font-size:90%">
# syntax
import &lt;module_name&gt;
					</code>
				</pre>
				<pre>
					<code style="font-size:90%;margin-top:-70px">
# ie, load a user-defined module, math_helper.py
import math_helper
					</code>
				</pre>
				<p class="dim" style="font-size:85%;margin-top:-30px">
					<span class="bright">import math_helper</span> imports the module <span class="bright">math_helper</span>, 
					and creates a reference to that module in the current namespace.
					<br>
					In other words, after you've run this statement, you can use
					<br>
					<span class="bright">math_helper.&lt;objects&gt;</span> 
					to refer to things defined in module <span class="bright">math_helper</span>.
				</p>
			</section>
			<section>
				<h3>Importing Modules</h3>
				<p class="dim" style="font-size:90%">
					Assume that we have this simple module:
				</p>
				<pre>
					<code>
"""
math_helper.py
"""

PI = 3.1416
VALUE_OF_E = 2.71828

def get_the_area_of_a_circle(radius):
    return PI * radius ** 2
	
def display_e():
    print(VALUE_OF_E)
					</code>
				</pre>
			</section>
			<section>
				<h3>Importing Modules</h3>
				<p class="dim" style="font-size:85%">
					If we import <span class="bright">math_helper.py</span>, we can now access definitions 
					and statements declared on that module.
					<br>
					That includes any assigned variables, defined functions, etc.
				</p>
				<pre>
					<code style="font-size:90%">
# load math_helper.py file
import math_helper

# access variables
radius = 10
print('Area of a circle with a radius of {radius} is: {area}'.format(
       radius=radius,
       area=math_helper.PI * radius ** 2
       )
)

# invoke function
math_helper.display_e()
					</code>
				</pre>
			</section>
			<section>
				<h3>Importing Modules</h3>
				<p class="dim" style="font-size:85%">
					We can also specify what variables, function definitions, etc to import directly. We can rewrite the code in the 
					previous slide like this:
				</p>
				<pre>
					<code style="font-size:90%;margin-top:-20px;">
# load math_helper.py file
from math_helper import PI, display_e

# access variables
radius = 10
print('Area of a circle with a radius of {radius} is: {area}'.format(
       radius=radius,
       area=PI * radius ** 2
       )
)

# invoke function
display_e()
					</code>
				</pre>
				<p class="dim" style="font-size:80%;margin-top:-50px;">
					By also using <span class="bright">from math_helper import *</span>, we can now reference all public objects
					defined on that module.
				</p>
			</section>
			<section>
				<h3>Importing Modules</h3>
				<p class="dim" style="font-size:85%">
					To check all references on the imported module, you can use the built-in 
					<span class="bright">help()</span> and <span class="bright">dir()</span> functions.
				</p>
				<pre>
					<code style="font-size:90%">
>>> import math_helper
>>> dir(math_helper)
['PI', 'VALUE_OF_E', '__builtins__', '__cached__', '__doc__', 
'__file__', '__loader__', '__name__', '__package__', '__spec__', 'display_e', 
'get_the_area_of_a_circle']

>>> help(math_helper)
Help on module math_helper:

NAME
    math_helper

FUNCTIONS
    display_e()

    get_the_area_of_a_circle(radius)

DATA
    PI = 3.1416
	VALUE_OF_E = 2.71828
	
FILE
    /path/to/math_helper.py
					</code>
				</pre>
			</section>
			<section>
				<h3>Executing Modules as Scripts</h3>
				<p class="dim" style="font-size:80%">
					Modules can also be sometimes run as a standalone program. When you run a Python module in the command line, 
					the code in the module will be executed, just as if you imported it, but with the <span class="bright">__name__</span> 
					set to <span class="bright">__main__</span>.
				</p>
				<pre>
					<code style="font-size:90%">
"""
math_helper.py
"""
# additional codes here

if __name__ == '__main__':
   print('Did you call me?')
					</code>
				</pre>
				<pre>
					<code style="font-size:90%;margin-top:-50px;">
$ python math_helper.py  # outputs "Did you call me?"
					</code>
				</pre>
			</section>
		</section>
	
		<!-- 
		Objects and Classes
		//-->
		<section>
			<h1>Objects<br>&amp;<br>Classes</h1>
		</section>
		<section>
			<section>
				<h3>Objects &amp; Classes</h3>
				<br>
				<p class="dim" style="font-size:90%">
					Python is an object oriented programming language.
					<br>
					<span class="bright">Object</span> is simply a collection of data (<span class="bright">attributes</span>) 
					and methods (<span class="bright">class functions</span>) that act on those data.
					<br>
					<br>
					<span class="bright">Class</span> is the blueprint (a sketch or prototype) for the object.
					<br>
					<br>
					An <span class="bright">object</span> is also called an <span class="bright">instance of a class</span> 
					and the process of creating this object is called <span class="bright">instantiation</span>.
				</p>
			</section>
			<section>
				<h2>Class</h2>
				<p class="dim" style="font-size:80%">
					Like function definitions begin with the keyword def, in Python, we define a class using the keyword <span class="bright">class</span>.
				</p>
				<pre>
					<code style="font-size:90%">
# syntax
class &lt;class_name&gt:
    # attributes and functions
					</code>
				</pre>
				<pre>
					<code style="font-size:90%;margin-top:-70px;">
# class definition
class MyClass(object):
    class_attribute = None  # also called "static" class variable
	
    def func(self [, params]):
        self.instance_attribute = False
        pass       # or returns something
					</code>
				</pre>
			</section>
			<section>
				<h3>Class Instantiation</h3>
				<p class="dim" style="font-size:80%">
					Supposed we have a sample class:
				</p>
				<pre>
					<code style="font-size:80%">
class MathHelper(object):
    PI = 3.1416
	
    def get_the_area_of_a_circle(self, radius):
        return self.PI * radius ** 2
					</code>
				</pre>
				<pre>
					<code style="font-size:80%;margin-top:-70px;">
# instantiate a MathHelper object
m = MathHelper()

# accessing class attribute
print(m.PI)
print(MathHelper.PI)  # statically accessed

# calling a method
print(m.get_the_area_of_a_circle(10))
					</code>
				</pre>
			</section>
			<section>
				<h3>Constructors</h3>
				<br>
				<p class="dim" style="font-size:85%">
					A <span class="bright">constructor</span> is a special method that is called when an object is instantiated.
					Python relies on the constructor to perform tasks such as initializing (assigning values to) 
					any instance attributes that the object will need when it starts.
					<br>
					<br>
					The constructor method name is <span class="bright">__init()__</span>.
					<br>
					<br>
					The constructor can accept arguments when necessary to create the object. 
					When you create a class without a constructor, Python automatically creates a default constructor 
					for you that doesn’t do anything.
				</p>
			</section>
			<section>
				<h3>Constructors</h3>
				<p class="dim" style="font-size:85%">
					The syntax for implementing it is shown below:					
				</p>
				<pre>
					<code style="font-size:90%;">
class &lt;class_name&gt;(object):
    def __init__(self [, params, ...]):
        # code block
					</code>
				</pre>
				<pre>
					<code style="font-size:90%;margin-top:-70px;">
class SerialComm(object):
    def __init__(self):
        print('SerialComm is initialized.')

# instantiate 
board = SerialComm()   # prints "SerialComm is initialized."
					</code>
				</pre>
				<p class="dim" style="font-size:80%;margin-top:-30px;">
					Just like functions, constructors can be set with whatever parameters you want (positional, default, keyword, arbitrary).
				</p>
			</section>
			<section>
				<h3>Constructors</h3>
				<p class="dim" style="font-size:85%">
					To pass arguments to it, pass it in the instantiation call:
				</p>
				<pre>
					<code style="font-size:90%;">
class SerialComm(object):
    def __init__(self, serial_port, baud_rate=9600):
        self.serial_port = serial_port
        self.baud_rate = baud_rate	

        print('Serial port "{port}" is initialized at {rate} baud rate'.format(
            rate=baud_rate,
            port=serial_port
            )
        )

# instantiate serial communication
board = SerialComm(serial_port='COM3')
print(board.baud_rate)
					</code>
				</pre>
				<p class="dim" style="font-size:80%;margin-top:-30px;">
					Unlike functions, constructors return anything but None.
				</p>
			</section>
			<section>
				<h3>Class: Things to Know</h3>
				<br>
				<ul class="dim" style="font-size:80%">
					<li>there are two (2) types of attributes: &nbsp;<span class="bright">class</span> and <span class="bright">instance</span></li>
					<li><span class="bright">class attributes</span> are shared by multiple objects instance of the same class</li>
					<li><span class="bright">self</span> refers to the current instance of the object</li>
					<li>Even though self is the first parameter, arguments passed to the method correspond only to the second parameter and up</li>
					<li>you can access other attributes and functions via self too</li>
					<li>The name of a constructor is always the same, <span class="bright">__init__()</span></li>
					<li>Just like functions, constructors can be set with whatever parameters you want (positional, default, keyword, arbitrary)</li>
					<li>Unlike functions, constructors <span class="bright">does not</span> return anything but None</li>
					<li>The order of precedence when variables are accessed -- 1) <span class="bright">instance attributes</span>, 
						then 2) <span class="bright">class attributes</span></li>
					</ul>
			</section>
		</section>
	
		<!-- 
		Tips
		//-->
		<section>
			<h1>Tips</h1>
		</section>
		<section>
			<section>
				<h2>Mutable vs. Immutable</h2>
				<p class="dim" style="font-size:90%">
					Not all python objects handle changes the same way. 
					Some objects are mutable, meaning they can be altered.  
					Others are immutable; they cannot be changed but rather return new objects when attempting to update.
					Typically, immutable objects are <span class="bright">hashable</span>.
				</p>
				<table>
				<tr>
					<td width="50%" style="vertical-align:top">
						<ul>
							<li>numbers</li>
							<li>strings</li>
							<li>booleans</li>
							<li>tuples</li>
							<li>frozensets</li>
							<li>bytes</li>
						</ul>
					</td>
					<td width="50%" style="vertical-align:top">
						<ul>
							<li>lists</li>
							<li>sets</li>
							<li>dictionaries</li>
							<li>bytearrays</li>
							<li>user-defined classes <span class="dim">(unless specifically made immutable)</span></li>
						</ul>
					</td>
				</tr>
				</table>
			</section>
			<section>
				<h2>Packing / Unpacking</h2>
				<p class="dim" style="font-size:85%">
					Variable <span class="bright">packing</span> in Python literally means packing several items/variables into one. 
					Unpacking is sometimes called <span class="bright">destructuring</span>.
				</p>
				<pre>
					<code style="font-size:90%;">
# destructuring as values
a, b = (1, 2)
print(a)     # prints 1
print(b)     # prints 2

# destructuring as list (Python 3.x only)
a, *b = 1,2,3,4,5
print(a)     # prints 1
print(b)     # prints [2,3,4,5]
					</code>
				</pre>
			</section>
		</section>
    </div>
</div>

<script src="assets/reveal.js/lib/js/head.min.js"></script>
<script src="assets/reveal.js/js/reveal.js"></script>
<script>
Reveal.initialize({
	controls: true,
	progress: true,
	history: true,
	center: true,
	transition: 'fade', // none/fade/slide/convex/concave/zoom
	// Optional reveal.js plugins
	dependencies: [
		{ src: 'assets/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
		{ src: 'assets/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
		{ src: 'assets/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
		{ src: 'assets/reveal.js/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
		{ src: 'assets/reveal.js/plugin/zoom-js/zoom.js', async: true },
		{ src: 'assets/reveal.js/plugin/notes/notes.js', async: true }
	]
});
</script>

</body>
</html>
